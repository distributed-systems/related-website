!function(){

    var   Class         = require('ee-class')
        , EventEmitter  = require('ee-event-emitter')
        , log           = require('ee-log')
        , Arguments     = require('ee-arguments')
        , type          = require('ee-types')
        , RPCRequest    = require('ee-soa-rpc-request')
        , SOAResponse   = require('ee-soa-response')
        , marked        = require('marked')
        , async         = require('ee-async');

        // set marked options
        marked.setOptions({
            breaks: true
        });

    module.exports = new Class({
        inherits: EventEmitter


        , init: function(namespace, accessToken) {
            this.Request = new RPCRequest(this);

            // index of namespaces
            Class.define(this, '_namespaces', Class({}));

            // the locally saved locales
            Class.define(this, '_locales', Class({}));

            // the accestoken of the underlaying service
            this.accessToken = accessToken;

            // check every 60 secs for updates
            setInterval(function(){
                Object.keys(this._namespaces).forEach(function(namespace){
                    this._load(namespace);
                }.bind(this));
            }.bind(this), 60000);
        }


        /*
         * load a bunch of locales, the callback will fire if all namespaces could be loaded
         * the init function starts an interval thats checking for loading errors, which it will
         * log so there is an indicator for problems
         */
        , load: function(namespace, callback) {
            process.nextTick(function() {
                if (type.string(namespace)) this._load(namespace, callback);
                else if (type.array(namespace)) async.each(namespace, this._load.bind(this), callback);
                else throw new Error('Namespace is typeof «'+type(namespace)+'», expected «string» or «array»!');
            }.bind(this));
        }


        /*
         * returns && renders locales
         */
        , get: function() {
            var   args      = new Arguments(arguments)
                , key       = args.getString()
                , language  = args.getStringByIndex(1)
                , data      = args.getObject()
                , callback  = args.getFunction()
                , text      = this._insertVariables((this._locales[language] && this._locales[language][key] ? this._locales[language][key] : ''), data);

            if (callback) callback(null, text);
            else return text;
        }


        /*
         * render a markdown text
         */
        , renderMarkdown: function(text) {
            return marked(text);
        }



        /*
         * build data structure for namespace storage
         */
        , _addNamespace: function(namespace) {
            if (type.string(namespace)) {
                if (!this._namespaces[namespace]) {
                    this._namespaces[namespace] = {
                          lastUpdated   : new Date(0)
                        , callbacks     : []
                        , interval      : 500
                    };
                    return false;
                }
                else return true;
            }
            else throw new Error('Namespace is typeof «'+type(namespace)+'», expected «string»!');
        }



        /*
         * gets locales from the service, return the callback as soon as all namespaces could be loaded
         */
        , _load: function(namespace, callback){
            var isUpdate = this._addNamespace(namespace);

            // store callback, should be called when the namespace was loade
            if (callback) this._namespaces[namespace].callbacks.push(callback);


            // request the data
            new this.Request({
                  select    : '*, resourceLocale.value, resourceLocale.language.code'
                , filter    : 'key=like("'+namespace+'%")'+(isUpdate ? ', updated>='+this._buildTimestamp(this._namespaces[namespace].lastUpdated) : '')
                , range     : '0-5000'
                , token     : this.accessToken
            }).send('resource', function(status, data) {
                if (status === SOAResponse.statusCodes.OK) {
                    this._storeResult(namespace, data);
                    this._namespaces[namespace].interval = 500;

                    process.nextTick(function() {
                        this._namespaces[namespace].callbacks.forEach(function(cb) {cb();});
                        this._namespaces[namespace].callbacks = [];
                    }.bind(this));
                }
                else {
                    // retry
                    if (this._namespaces[namespace].interval <= 60000) this._namespaces[namespace].interval *= 1.1;

                    setTimeout(function() {
                        this._load(namespace);
                    }.bind(this), this._namespaces[namespace].interval);
                }
            }.bind(this));
        }




        /*
         * create timestamps for the queries sent to the server
         */
        , _buildTimestamp: function(date) {
            return date.getFullYear()+'-'+(this._pad(date.getMonth()+1))+'-'+this._pad(date.getDate())+' '+this._pad(date.getHours())+':'+this._pad(date.getMinutes())+':'+this._pad(date.getSeconds());
        }






        /**
         * add missing zeroes
         */
        , _pad: function(input) {
            input = input + '';
            if (input.length === 1) return '0'+input;
            else return input;
        }



        /*
         * save data received from the service
         */
        , _storeResult: function(namespace, data) {
            if (data && data instanceof Array) {
                data.forEach(function(locale){
                    var isMarkdown;

                    if (locale && locale.resourceLocale && locale.resourceLocale.length) {
                        isMarkdown = locale.key.substr(-3) === '.md';

                        // set lastUpdated
                        if (new Date(locale.updated) > this._namespaces[namespace].lastUpdated) this._namespaces[namespace].lastUpdated = new Date(locale.updated);

                        locale.resourceLocale.forEach(function(languageVersion) {
                            var text = languageVersion.value;

                            if (!this._locales[languageVersion.language.code]) this._locales[languageVersion.language.code] = {};

                            this._locales[languageVersion.language.code][locale.key] = this._compileVariables(isMarkdown ? this.renderMarkdown(text) : text);
                        }.bind(this));
                    }
                }.bind(this));
            }
        }



        /*
         * insert variables into text
         */
        , _insertVariables: function(text, variables) {
            var   resultText = ''
                , currentText;

            if (type.array(text)) {
                for(var i = 0, l = text.length; i < l; i++) {
                    currentText = text[i];

                    if (currentText.isVariable) resultText += typeof variables[currentText.key] === undefined ? '' : variables[currentText.key];
                    else resultText += currentText;
                }
                return resultText;
            }
            return text;
        }


        /*
         * compile a string containing variables so that they can be filled fast
         */
        , _compileVariables: function(text) {
            var   findReg       = /%([a-z0-9\.\-_]+)%/gi
                , compiledText  = []
                , lastIndex     = 0
                , variable
                , result;

            while (result = findReg.exec(text)) {
                if (result.index) compiledText.push(text.substring(lastIndex, result.index));
                compiledText.push({isVariable: true, key: result[1]});
                lastIndex = result.index+result[1].length+2;
            }


            if (!compiledText.length) return text;
            else {
                if (lastIndex < text.length) compiledText.push(text.substr(lastIndex));
                return compiledText;
            }
        }
    });
}();
